@gen (static) function lambda_fa(arg1::Real, arg2::Real)
	fa = @trace(gamma(arg1, arg2), :fa)
	return fa
end

@gen (static) function miss_rate(arg1::Real, arg2::Real)
	miss = @trace(beta(arg1, arg2), :miss)
	return miss
end

"""
	make_visual_system(params::Video_Params)

Samples the matrix describing the initial visual system.
"""
@gen (static) function make_visual_system(params::Video_Params)
	arg1 = fill(1.0, length(params.possible_objects))
	arg2 = fill(1.0, length(params.possible_objects))
	fa = @trace(Map(lambda_fa)(arg1, arg2), :lambda_fa) #these are lambdas per receptive field
	miss = @trace(Map(miss_rate)(arg1, arg2), :miss_rate) #miss rate is misnomer. it's actually more like detection rate. it's mean of geometric distribution

	v = hcat(fa, miss)
   	return convert(Matrix{Real}, v)
end
################################################################################

"""
	main(num_videos::Int64, num_frames::Int64)

Simulates the visual system, `num_videos` scenes each with
`num_frames` frames, and percepts generated by the visual system.

arg lesioned is about whether or not to have the V kernel reflect an ideal observed
updating their beliefs as opposed to just resampling V from the prior
"""
@gen (static) function main(lesioned::Bool, num_videos::Int64, num_frames::Int64, params::Video_Params)

	receptive_fields = make_receptive_fields(params)

	init_v_matrix = @trace(make_visual_system(params), :init_v_matrix)
	alphas = fill(1, size(init_v_matrix))
	betas = fill(1, size(init_v_matrix))
	v_matrix_state = (init_v_matrix, alphas, betas)
	#println("alphas in main ", v_matrix_state[2])
    videos = @trace(video_chain(num_videos, v_matrix_state, lesioned, num_frames, params, receptive_fields), :videos)
	return videos
end

export main
export make_visual_system
